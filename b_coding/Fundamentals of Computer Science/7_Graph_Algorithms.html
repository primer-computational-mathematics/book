

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Graph Algorithms &#8212; ESE Jupyter Material</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/sphinx-book-theme.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".cell"
        const thebe_selector_input = ".cell_input div.highlight"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Intro to Python" href="../Intro to Python/intro.html" />
    <link rel="prev" title="Data Structures" href="6_Data_Structures.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">ESE Jupyter Material</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  
  <ul class="nav sidenav_l1">
  <li class="">
    <a href="../../intro.html">Landing page</a>
  </li>
  <li class="">
    <a href="../../a_modules/intro.html">Modules</a>
  </li>
  <li class="active">
    <a href="../intro.html">Coding</a>
  <ul class="nav sidenav_l2">
    <li class="">
      <a href="../NumPy_Arrays.html">NumPy arrays</a>
    </li>
    <li class="active">
      <a href="intro.html">Fundamentals of Computer Science</a>
      <ul class="nav sidenav_l3">
      <li class="">
        <a href="1_Algorythmic_Complexity.html">Algorithmic complexity</a>
      </li>
      <li class="">
        <a href="2_Recursion.html">Recursion</a>
      </li>
      <li class="">
        <a href="3_Divide_and_Conquer.html">Divide and Conquer</a>
      </li>
      <li class="">
        <a href="4_Dynamic_Programming.html">Dynamic Programming</a>
      </li>
      <li class="">
        <a href="5_Greedy_Algorithms.html">Greedy Algorithms</a>
      </li>
      <li class="">
        <a href="6_Data_Structures.html">Data Structures</a>
      </li>
      <li class="active">
        <a href="">Graph Algorithms</a>
      </li>
    </ul>
    </li>
    <li class="">
      <a href="../Intro to Python/intro.html">Intro to Python</a>
    </li>
    <li class="">
      <a href="../Pandas/intro.html">Pandas</a>
    </li>
    <li class="">
      <a href="../Programming Tools/intro.html">Programming tools</a>
    </li>
  </ul>
  </li>
  <li class="">
    <a href="../../c_mathematics/intro.html">Mathematics</a>
  </li>
  <li class="">
    <a href="../../d_geosciences/intro.html">Geosciences</a>
  </li>
  <li class="">
    <a href="../../e_extra/intro.html">Further resources</a>
  </li>
  <li class="">
    <a href="../../genindex.html">Index</a>
  </li>
</ul>
</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/b_coding/Fundamentals of Computer Science/7_Graph_Algorithms.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        
        <a class="issues-button"
            href="https://github.com/primer-computational-mathematics/book/issues/new?title=Issue%20on%20page%20%2Fb_coding/Fundamentals of Computer Science/7_Graph_Algorithms.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/primer-computational-mathematics/book/master?urlpath=tree/notebooks/b_coding/Fundamentals of Computer Science/7_Graph_Algorithms.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

    </div>
    <div class="d-none d-md-block col-md-2 bd-toc show">
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#graph" class="nav-link">Graph</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#graph-traversal" class="nav-link">Graph traversal</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#breadth-first-search-bfs" class="nav-link">Breadth-first search (BFS)</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#depth-first-search-dfs" class="nav-link">Depth-first search (DFS)</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#minimum-spanning-tree-mst" class="nav-link">Minimum spanning tree (MST)</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#kruskal-s-algorithm" class="nav-link">Kruskal’s algorithm</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#prim-s-algorithm" class="nav-link">Prim’s algorithm</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#references" class="nav-link">References</a>
        </li>
    
    </ul>
</nav>


    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="graph-algorithms">
<span id="id1"></span><h1>Graph Algorithms<a class="headerlink" href="#graph-algorithms" title="Permalink to this headline">¶</a></h1>
<div class="section" id="graph">
<span id="index-0"></span><h2>Graph<a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h2>
<p>In broad terms. A graph \((V,E)\) is an abstract structure consisting of nodes (<em>vertices</em>) and edges connecting some of them. Graphs can be directed or undirected which means that their edges can be traversed in one or both directions. Graphs can be unweighted or not, their edges can have assigned weights. There are several ways of representing graphs in computers, two of which are:</p>
<ul class="simple">
<li><p>Adjecency matrix \(A\): Which are matrices consisting of \(1\) and \(0\). A \(1\) at a coordinates \((i,j)\) means that there is an edge from node \(i\) to node \(j\). For undirected graphs \(A[i,j]\) = \(A[j,i]\). Adjacency matricex are a compact way of representing <em>dense</em> graphs where the number of edges is close to \(|V|^2\).</p></li>
<li><p>Adjacency list \(L\): which is a 2D array where an entry \(L[i]\) is a list with the ids of nodes to which \(i\) is connected to. It is a space-efficient representation for <em>sparse</em> graphs where not many nodes are connected.</p></li>
</ul>
<div class="figure align-default">
<a class="reference internal image-reference" href="../../_images/Graphs.png"><img alt="../../_images/Graphs.png" src="../../_images/Graphs.png" style="width: 60%;" /></a>
</div>
<p>Depending on the algorithm we will use one of those representations.</p>
</div>
<div class="section" id="graph-traversal">
<h2>Graph traversal<a class="headerlink" href="#graph-traversal" title="Permalink to this headline">¶</a></h2>
<p><em>Traversing</em> a graph means visiting all if its nodes in some order. There are two basic algorithms to which achieve that goal.</p>
<div class="section" id="breadth-first-search-bfs">
<h3>Breadth-first search (BFS)<a class="headerlink" href="#breadth-first-search-bfs" title="Permalink to this headline">¶</a></h3>
<p>The name of this graph traversal stems from the way it visits the nodes. It starts at some arbitrarily chosen node and then visits all the nodes that are distance 1 away from it, then distance 2 etc. BFS will not visit a node that is distance \(d+1\) until it visits all nodes at a distance \(d\). When two nodes are equal distance from the first node, the choice is also arbitrary (we will go for the numerical order).</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/4/46/Animated_BFS.gif" width="40%">
<p>Source: <a class="reference external" href="https://upload.wikimedia.org/wikipedia/commons/4/46/Animated_BFS.gif">Wikimedia Commons</a></p>
<p>We will divide the nodes of the graph into three kinds: white, grey and black. White nodes are unvisited, grey are being considered and black are already visited. Grey nodes are a queue, first in last out.
In words, the algorithm will work as follows:</p>
<ol class="simple">
<li><p>Add all nodes to the white list.</p></li>
<li><p>Choose an arbitrary white node, put it in the grey queue.</p></li>
<li><p>Consider all nodes connected to the node, that are white, add them to the grey queue one by one.</p></li>
<li><p>Move the node considered to the black list.</p></li>
<li><p>If the grey queue is not empty, take another grey node and come back to the 3rd step.</p></li>
<li><p>If the white list is not empty, come back to the 2nd step, otherwise terminate.</p></li>
</ol>
<p>The following implementations print the node id as they are added to the black list.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="c1"># adjacency matrix implementation</span>
<span class="c1"># indexing from 0, different from the diagram</span>
<span class="k">def</span> <span class="nf">matrixBFS</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">white</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)))</span>
    <span class="n">grey</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">black</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># initalise the queue</span>
    <span class="n">grey</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">white</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># consider a node</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">grey</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">black</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="c1"># consider the nodes connected to the current node</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">curr</span><span class="p">])):</span>
            <span class="c1"># add to grey if not previously seen</span>
            <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">curr</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">white</span><span class="p">:</span>
                <span class="n">grey</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">white</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="c1"># check if all components if the graph is no connected</span>
        <span class="c1"># if all nodes checked terminate</span>
        <span class="k">if</span> <span class="n">grey</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">))):</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">black</span><span class="p">:</span>
                    <span class="n">grey</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">white</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">grey</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
                <span class="k">break</span>

<span class="k">def</span> <span class="nf">listBFS</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">white</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)))</span>
    <span class="n">grey</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">black</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">grey</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">white</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">grey</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">black</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">curr</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">white</span><span class="p">:</span>
                <span class="n">grey</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">white</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grey</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">))):</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">black</span><span class="p">:</span>
                    <span class="n">grey</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">white</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">grey</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
                <span class="k">break</span>
<span class="c1"># Undirected            </span>
<span class="c1"># 0   1</span>
<span class="c1"># | \</span>
<span class="c1"># 2 - 3</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> 
<span class="n">matrixBFS</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[]]</span>
<span class="n">listBFS</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="c1"># Directed</span>
<span class="c1"># 0    1</span>
<span class="c1"># /\ \  /\</span>
<span class="c1"># ||  \ |</span>
<span class="c1"># \/  \/| </span>
<span class="c1"># 2     3</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> 
<span class="n">matrixBFS</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[],[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">listBFS</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0
2
3
1

0
2
3
1

0
2
3
1

0
2
3
1
</pre></div>
</div>
</div>
</div>
<p>There are many uses of the BFS algorithm, some of which are:</p>
<ol class="simple">
<li><p>Finding a MST (see below) in an unweighted graph.</p></li>
<li><p>Fining a minimum path in an unweighted graph (initial node has to be at the end of the searched path).</p></li>
<li><p>Detecting cycles in graphs (by encountering a visited node).</p></li>
<li><p>Finding all nodes within a connected component.</p></li>
</ol>
</div>
</div>
<div class="section" id="depth-first-search-dfs">
<h2>Depth-first search (DFS)<a class="headerlink" href="#depth-first-search-dfs" title="Permalink to this headline">¶</a></h2>
<p>In DFS we will always go <em>deeper</em> into the graph whenever possible. We start at an arbitrary node and then go to the first possible via an edge. This is repeated until we reach a node which has only edges to already visited nodes (or no edges). We then trace back to the previous node in this procedure. We continue until all nodes are visited.</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif" width="40%">
<p>Source: <a class="reference external" href="https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif">Wikimedia Commons</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># DFS for matrix representation</span>
<span class="k">def</span> <span class="nf">matrixDFS</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># initalise</span>
    <span class="n">white</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)))</span>
    <span class="n">black</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">white</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">white</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">white</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">black</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="c1"># recursive helper function</span>
        <span class="n">DFShelper</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="n">root</span><span class="p">,</span><span class="n">black</span><span class="p">,</span><span class="n">white</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DFShelper</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">root</span><span class="p">])):</span>
        <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">white</span><span class="p">:</span>
            <span class="n">white</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">black</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">DFShelper</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            
<span class="c1"># Undirected            </span>
<span class="c1"># 0   1</span>
<span class="c1"># | \</span>
<span class="c1"># 2 - 3</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> 
<span class="n">matrixDFS</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

<span class="c1"># Directed</span>
<span class="c1"># 0    1</span>
<span class="c1"># /\ \  /\</span>
<span class="c1"># ||  \ |</span>
<span class="c1"># \/  \/| </span>
<span class="c1"># 2     3</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> 
<span class="n">matrixDFS</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
2
0
1

2
1
3
0
</pre></div>
</div>
</div>
</div>
<p>Time complexity of DFS is \(O(|V|+|E|)\). It can be used in the following problems:</p>
<ol class="simple">
<li><p>Detecting cycles</p></li>
<li><p>Augmented DFS can find the MST of a graph</p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Topological_sorting">Topological sorting</a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Strongly_connected_component">Finding strongly connected components of a graph</a></p></li>
</ol>
</div>
<div class="section" id="minimum-spanning-tree-mst">
<h2>Minimum spanning tree (MST)<a class="headerlink" href="#minimum-spanning-tree-mst" title="Permalink to this headline">¶</a></h2>
<p>A <em>spanning tree</em> of a graph \(G\) is a subgraph of \(G\) that includes all its nodes. The concept is meaningful for connected graphs only (if the graph is not connected we are considering its <em>spanning forest</em>). The problem of MST is considered for weighted graphs \((V,E\) with \(w\) - a function that returns the weight of an edge in \(E\). A <em>minimum spanning tree</em> is one in which the sum of weights of the edges is minimal. Surprisingly, the problem can be solved by using a <em>greedy</em> approach. Here are two possible approaches:</p>
<div class="section" id="kruskal-s-algorithm">
<h3>Kruskal’s algorithm<a class="headerlink" href="#kruskal-s-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Kruskal’s approach is based on the following procedure:</p>
<ol class="simple">
<li><p>Create a single element set for every node.</p></li>
<li><p>Sort the edges in \(E\) by weight in non-decreasing order, put them in a priority queue.</p></li>
<li><p>Take the edge of least weight and if it connects elements from different sets, use it. Make the connected sets one (by setting the same group leader).</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">find(u)</span></code> method will find the leader of a group. <code class="docutils literal notranslate"><span class="pre">u,v</span></code> are in the same group if <code class="docutils literal notranslate"><span class="pre">find(u)</span> <span class="pre">==</span> <span class="pre">find(v)</span></code>.
<code class="docutils literal notranslate"><span class="pre">union(u,v)</span></code> will join two sets. The leader will be the leader of the set of more elements, otherwise arbitrary.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># we will use a matrix representation as a list of edges [source, dest, weight]</span>
<span class="c1"># we are also given the number of nodes</span>
<span class="c1"># assuming undirected graph</span>
<span class="k">def</span> <span class="nf">mst_kruskal</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">sets</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">mst</span> <span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># [leader, number of elems]</span>
        <span class="n">sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">sets</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">sets</span><span class="p">):</span>
            <span class="n">mst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">union</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">sets</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mst</span>
    
    
<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">sets</span><span class="p">):</span>
    <span class="c1"># go up in parents</span>
    <span class="k">while</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">sets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span>
        
<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">leader_u</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">sets</span><span class="p">)]</span>
    <span class="n">leader_v</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">sets</span><span class="p">)]</span>
    <span class="c1">#compare which set is bigger</span>
    <span class="k">if</span> <span class="n">leader_u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">leader_v</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">leader_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">leader_u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">leader_u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">leader_v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">leader_u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">leader_u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">leader_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">leader_v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">leader_u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">leader_v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
<span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mst_kruskal</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[0, 3, 1], [1, 5, 3], [0, 2, 4], [0, 1, 6], [0, 4, 7]]
</pre></div>
</div>
</div>
</div>
<p>Kruskal’s algorithm runs in \(O(|E|log|E|)\) time, which is also \(O(|E|log|V|)\) as \(|E| \leq |V|^2\).</p>
</div>
<div class="section" id="prim-s-algorithm">
<h3>Prim’s algorithm<a class="headerlink" href="#prim-s-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Prim’s algorithm is similar to Kruskal’s but at each step, there is only one tree that grows. The idea is as follows:</p>
<ol class="simple">
<li><p>Start at an arbitrary node in \(G\)</p></li>
<li><p>Take the minimum edge incident on one of the already considered nodes (that connects it to the node not previously seen). This way the tree expands.</p></li>
<li><p>When all nodes are in the tree, terminate.</p></li>
</ol>
<p>Of course, the 2nd step may be a bit tricky to implement efficiently. We will use a <em>priority queue</em> from the <code class="docutils literal notranslate"><span class="pre">heapq</span></code> interface to efficiently choose the next edge to add. We also need to upgrade our adjacency list representation of the graph. Now it is a dictionary which maps to a dictionary with incident nodes as keys and their corresponding edge weights as values. So <code class="docutils literal notranslate"><span class="pre">graph[from][to]</span></code> gives the desired edge if it exists. It assumes that there is at most one edge between any two nodes (undirected graph), if this is violated, we would always choose the edge of minimum weight.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">heapq</span>

<span class="c1"># we will work on an adjacency list representation</span>
<span class="k">def</span> <span class="nf">mst_prim</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">starting_vertex</span><span class="p">):</span>
    <span class="c1"># defaultdict returns set() in case the key is not in the dict</span>
    <span class="c1"># this is an adjacency list representation</span>
    <span class="n">mst</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="c1"># at the beginning only the starting_node is visited</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">starting_vertex</span><span class="p">])</span>
    <span class="c1"># get the edges incident on the starting_vertex</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">starting_vertex</span><span class="p">,</span> <span class="n">to</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">to</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">starting_vertex</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">]</span>
    <span class="c1"># create a min-heap based on the cost of the esge</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="n">edges</span><span class="p">:</span>
        <span class="c1"># take the minimum cost edge</span>
        <span class="n">cost</span><span class="p">,</span> <span class="n">frm</span><span class="p">,</span> <span class="n">to</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">to</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="c1"># add the new node to the visited</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">to</span><span class="p">)</span>
            <span class="c1"># expand the tree</span>
            <span class="n">mst</span><span class="p">[</span><span class="n">frm</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">to</span><span class="p">)</span>
            <span class="c1"># add the edges incident on the new node</span>
            <span class="c1"># which lead to the not visited nodes</span>
            <span class="k">for</span> <span class="n">to_next</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">to</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># add to the heap</span>
                <span class="k">if</span> <span class="n">to_next</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">to_next</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">mst</span>

<span class="n">example_graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
<span class="p">}</span>

<span class="nb">print</span><span class="p">(</span><span class="n">mst_prim</span><span class="p">(</span><span class="n">example_graph</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>defaultdict(&lt;class &#39;set&#39;&gt;, {&#39;A&#39;: {&#39;B&#39;}, &#39;B&#39;: {&#39;D&#39;, &#39;C&#39;}, &#39;D&#39;: {&#39;E&#39;}, &#39;E&#39;: {&#39;F&#39;}, &#39;F&#39;: {&#39;G&#39;}})
</pre></div>
</div>
</div>
</div>
<p>The algorithm runs in \(O(|E|log|V|)\) time. Why?</p>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Cormen, Leiserson, Rivest, Stein, “Introduction to Algorithms”, Third Edition, MIT Press, 2009</p></li>
<li><p>GeeksforGeeks, <a class="reference external" href="https://www.geeksforgeeks.org/applications-of-breadth-first-traversal/?ref=rp">Applications of Breadth First Traversal</a></p></li>
<li><p>Vijini Mallawaarachchi, Medium, Towards Data Science, <a class="reference external" href="https://towardsdatascience.com/10-graph-algorithms-visually-explained-e57faa1336f3">10 Graph Algorithms Visually Explained</a>, 2020</p></li>
<li><p>Brad Filed, Practical Algorithms and Data Structures, <a class="reference external" href="https://bradfieldcs.com/algos/graphs/prims-spanning-tree-algorithm/">Prim’s Spanning Tree Algorithm</a>, 2020</p></li>
</ul>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "primer-computational-mathematics/book",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./b_coding/Fundamentals of Computer Science"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="6_Data_Structures.html" title="previous page">Data Structures</a>
    <a class='right-next' id="next-link" href="../Intro to Python/intro.html" title="next page">Intro to Python</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Imperial College London<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../../_static/js/index.js"></script>
    
  </body>
</html>