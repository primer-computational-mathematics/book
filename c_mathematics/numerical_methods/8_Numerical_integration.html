

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Numerical integration &#8212; ESE Jupyter Material</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/sphinx-book-theme.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/mystnb.js"></script>
    <script src="../../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".cell"
        const thebe_selector_input = ".cell_input div.highlight"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Roots of equations" href="9_Roots_of_equations.html" />
    <link rel="prev" title="Forward Time Centred Space scheme" href="7_Forward_time_centred_space.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">ESE Jupyter Material</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  
  <ul class="nav sidenav_l1">
  <li class="">
    <a href="../../intro.html">Landing page</a>
  </li>
  <li class="">
    <a href="../../a_modules/intro.html">Modules</a>
  </li>
  <li class="">
    <a href="../../b_coding/intro.html">Coding</a>
  </li>
  <li class="active">
    <a href="../intro.html">Mathematics</a>
  <ul class="nav sidenav_l2">
    <li class="">
      <a href="../calculus/intro.html">Calculus</a>
    </li>
    <li class="">
      <a href="../complex_analysis/intro.html">Complex analysis</a>
    </li>
    <li class="">
      <a href="../differential_equations/intro.html">Differential equations</a>
    </li>
    <li class="">
      <a href="../linear_algebra/intro.html">Linear algebra</a>
    </li>
    <li class="">
      <a href="../mathematical_notation/intro.html">Mathematical notation</a>
    </li>
    <li class="active">
      <a href="intro.html">Numerical methods</a>
      <ul class="nav sidenav_l3">
      <li class="">
        <a href="1_Interpolation_curve_fitting.html">Interpolation and curve fitting</a>
      </li>
      <li class="">
        <a href="2_Numerical_differentiation.html">Numerical differentiation</a>
      </li>
      <li class="">
        <a href="3_Timestepping_an_ODE.html">Solving or timestepping an ODE</a>
      </li>
      <li class="">
        <a href="4_Heuns_method.html">Heun’s method</a>
      </li>
      <li class="">
        <a href="5_Runge_Kutta_method.html">Runge-Kutta method</a>
      </li>
      <li class="">
        <a href="6_Solving_PDEs_SOR.html">Successive over-relaxation method</a>
      </li>
      <li class="">
        <a href="7_Forward_time_centred_space.html">Forward Time Centred Space scheme</a>
      </li>
      <li class="active">
        <a href="">Numerical integration</a>
      </li>
      <li class="">
        <a href="9_Roots_of_equations.html">Roots of equations</a>
      </li>
      <li class="">
        <a href="10_linear_algebra_intro.html">Linear algebra introduction</a>
      </li>
      <li class="">
        <a href="11_Gaussian_elimination.html">Gaussian elimination</a>
      </li>
      <li class="">
        <a href="12_LU_decomposition.html">LU decomposition</a>
      </li>
      <li class="">
        <a href="13_ill_conditioning_errors.html">Ill-conditioning and roundoff errors</a>
      </li>
      <li class="">
        <a href="14_iterative_methods_to_solve_matrix.html">Iterative methods to solve a matrix</a>
      </li>
      <li class="">
        <a href="BTCS.html">BTCS Scheme</a>
      </li>
      <li class="">
        <a href="BTCS_20200820.html">BTCS Scheme</a>
      </li>
    </ul>
    </li>
    <li class="">
      <a href="../series_and_sequences/intro.html">Series and sequences</a>
    </li>
    <li class="">
      <a href="../sets_and_functions/intro.html">Sets and functions</a>
    </li>
    <li class="">
      <a href="../statistics/intro.html">Statistics</a>
    </li>
  </ul>
  </li>
  <li class="">
    <a href="../../d_geosciences/intro.html">Geosciences</a>
  </li>
  <li class="">
    <a href="../../e_extra/intro.html">Further resources</a>
  </li>
  <li class="">
    <a href="../../genindex.html">Index</a>
  </li>
</ul>
</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/c_mathematics/numerical_methods/8_Numerical_integration.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        
        <a class="issues-button"
            href="https://github.com/primer-computational-mathematics/book/issues/new?title=Issue%20on%20page%20%2Fc_mathematics/numerical_methods/8_Numerical_integration.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/primer-computational-mathematics/book/master?urlpath=tree/notebooks/c_mathematics/numerical_methods/8_Numerical_integration.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

    </div>
    <div class="d-none d-md-block col-md-2 bd-toc show">
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#example" class="nav-link">Example</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#midpoint-rule-rectangle-method" class="nav-link">Midpoint rule (rectangle method)</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#implementation" class="nav-link">Implementation</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#trapezoid-rule" class="nav-link">Trapezoid rule</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#error-analysis" class="nav-link">Error analysis</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#concave-down-functions" class="nav-link">Concave-down functions</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#simpson-s-rule" class="nav-link">Simpson’s rule</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#composite-simpson-s-rule" class="nav-link">Composite Simpson’s rule</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#weddle-s-rule" class="nav-link">Weddle’s rule</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#id1" class="nav-link">Implementation</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#other-rules" class="nav-link">Other rules</a>
        </li>
    
    </ul>
</nav>


    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="numerical-integration">
<span id="nm-num-integration"></span><h1>Numerical integration<a class="headerlink" href="#numerical-integration" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="../../a_modules/intro.html#module-nm"><span class="std std-ref"><!-- module-nm badge --><span class="module module-nm">Numerical Methods</span></span></a></p>
<p id="index-0">Numerical integration involves finding the integral of a function. While <a class="reference external" href="https://www.sympy.org/en/index.html">SymPy</a> can be used to do analytical integration, there are many functions for which finding an analytical solution to integration is very difficult, and numerical integration is used instead.</p>
<p>To understand how to perform numerical integration, we first need to understand what exactly is the purpose of integration. For a 1D function, integration means finding the area underneath the curve. However, integration can also be extended for a 2D function and even a 3D function.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Numerical_integration">Quadrature</a> is the term used for numerical evaluation of a <em>definite</em> (i.e. over a range \([a,b]\)) integral, or in 1D finding the area under a curve.</p>
<p style="text-align:center;"><img src="https://upload.wikimedia.org/wikipedia/commons/f/f2/Integral_as_region_under_curve.svg" width="400px"></p>
<p>Source: <a class="reference external" href="https://upload.wikimedia.org/wikipedia/commons/f/f2/Integral_as_region_under_curve.svg">Wikipedia</a></p>
<div class="admonition-wondered-why-the-symbol-of-integration-looks-like-this-int admonition">
<p class="admonition-title">Wondered why the symbol of integration looks like this <span class="math notranslate nohighlight">\(\int\)</span>?</p>
<p>The symbol of integration actually comes from the cursive of capital letter \(S\), meaning summation. But why would it come from the idea of summation? Well, integration is very much related to summation.</p>
</div>
<p>We know that for a 1D function, which will be our primary topic of discussion today, if we evaluate an integral, we find the area under the function, as illustrated in the figure above. If your curve was a straight line (remember, straight lines are but a subset of curves which has no curves), then it would be rather straightforward to calculate the area under the curve, since you would either have a rectangle if your line was a horizontal straight line, or a trapezoid if your line was not a horizontal straight line. Yet, what happens if your line got a bunch of bend and curves?</p>
<p>For example, we could have a very simple equation like</p>
<p>\[f(x) = \sin(x) +5.\]</p>
<p>This equation is a sinusoidal function, of much more complicated shape that is not as easy to get the area through a rectangle or a trapezoid. Therefore, integration comes in to help you find the area. But how does the integration actually get you the area underneath the curve?</p>
<p>Well, what integration essentially does is basically breaking the area into smaller and smaller parts, evaluating the area of each part, and then summing each small part together. The small part of the area can be approximated to be a rectangle, a trapezoid, or some other weird shape if you find it suitable.</p>
<p>A very simple example, using rectangles are shown below:</p>
<p style="text-align:center;"><img src="https://upload.wikimedia.org/wikipedia/commons/2/28/Riemann_integral_regular.gif" width="400px"></p>
<p>Source: <a class="reference external" href="https://upload.wikimedia.org/wikipedia/commons/2/28/Riemann_integral_regular.gif">Wikipedia</a></p>
<div class="margin sidebar">
<p class="sidebar-title">Note</p>
<p>It should also be noted that although the example shown uses rectangular slices, it is not neccesary to use rectangular slices. It is not even neccessary to use slices that are of the the same width. Even if you used slices with different width, and which are not rectangles, like trapezoids for example, you could still make the slices increasingly thinner so that the summation of the area under the slices comes closer and closer to the area underneath the curve, until the slices become infinitely thin, and the summed area of slices becomes essentially equal to the area under the curve.</p>
</div>
<p>As each rectangle slice becomes thinner and thinner, the summed area from the rectangles become more and more closely fitting to the area under the curve. It should be understood that if the rectangle slice becomes infinitely thin, then the summed area from the rectangle would become so close to the area underneath the curve that the two would be essentially the same. You may find the mathematics for the Riemann integral on <a class="reference external" href="https://en.wikipedia.org/wiki/Riemann_integral">Wikipedia</a>. Of course, integration has come a long way since the Riemann integral, and other integrals were developed to deal with the deficiencies with the Riemann integral.</p>
<p>The choice of approximation method, as well as the size of the intervals, will control the error. Better methods as well as smaller (i.e. more to cover our total interval of interest: \([a,b]\)) sub-intervals will lead to lower errors, but will generally cost more to compute.</p>
<p>Here the following quadrature methods will be covered in the context of a simple function:</p>
<ul class="simple">
<li><p>Midpoint rule (also known as the rectangle method)</p></li>
<li><p>Trapezoid rule</p></li>
<li><p>Simpson’s rule</p></li>
<li><p>Composite Simpson’s rule</p></li>
<li><p>Weddle’s rule.</p></li>
</ul>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>Let’s begin with a simple function to demonstrate some of the most basic methods for performing numerical integration:</p>
<p>\[f\left ( x \right ) := \sin \left ( x \right ),\]</p>
<p>and assume that we want to know what the area under the, \(\sin\) function between 0 and \(\pi\), i.e. \([a,b]=[0,\pi]\).</p>
<p>The indefinite integral (or anti-derivative) of \(\sin \left ( x \right )\) is of course \(-\cos \left ( x \right )\) (plus a constant of integration, \(C\), which we can simply ignore as we saw above as it drops out as soon as we perform a <em>definite</em> integral).</p>
<p>Since we know the indefinite integral exactly in this case, we can perform the definite integration (i.e. find the area under the curve) ourselves exactly by hand:</p>
<p>\[I :=  \int_{0}^{\pi} \sin \left ( x \right ) = \left [ -\cos\left ( x \right )+ C \right ]_{0}^{\pi} =-\cos\left ( \pi \right ) - (-\cos\left ( 0 \right )) =-\cos\left ( \pi \right ) + \cos\left ( 0 \right ) = -(-1) + 1 = 2.\]</p>
<p>We included the constant \(C\) here to just to emphasise again the fact that it’s present doesn’t matter - we can just not write it down in this type of expression.</p>
<p>Let’s start by plotting the function between these points.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Set up the figure</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

<span class="c1"># Get the value of pi from numpy and generate 100 equally spaced values from 0 to pi.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># Calculate sin at these points.</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># plot</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>

<span class="c1"># Set x axis limits between 0 and pi.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">])</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">])</span>

<span class="c1"># Label axis.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x)=\sin(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;An example function we wish to integrate&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

<span class="c1"># Overlay a grid.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/8_Numerical_integration_1_0.png" src="../../_images/8_Numerical_integration_1_0.png" />
</div>
</div>
</div>
<div class="section" id="midpoint-rule-rectangle-method">
<span id="nm-midpoint-rule"></span><h2>Midpoint rule (rectangle method)<a class="headerlink" href="#midpoint-rule-rectangle-method" title="Permalink to this headline">¶</a></h2>
<p>The <strong>midpoint rule</strong> is perhaps the simplest quadrature rule. For reasons you will see below it is sometimes also called the <strong>rectangle method</strong>.</p>
<p>Consider one of the subintervals \([x_i, x_{i+1}]\). The midpoint rule approximates the integral over this (the \(i\)-th) subinterval by the area of a rectangle, with a base of length \((x_{i+1}-x_i)\) and a height given by the value of \(f(x)\) at the midpoint of that interval (i.e. at \(x=(x_{i+1}+x_i)/2\)):</p>
<p>\[ I_M^{(i)} := (x_{i+1}-x_i) \times f \left ( \frac {x_{i+1}+x_i} {2} \right ), \quad\text{for}
\quad 0\le i \le n-1.\]</p>
<p>The midpoint estimate of \(I\) then simply involves summing up over all the subintervals:</p>
<p>\[I_M := \sum_{i=0}^{n-1} , f \left ( \frac {x_{i+1}+x_i} {2} \right ), (x_{i+1}-x_i).\]</p>
<p>Midpoint rule:</p>
<ol>
<li><p>Divide the interval you want to calculate the area under the curve for into smaller pieces, each will be called a subinterval.</p></li>
<li><p>Assume that the interval begins at \(x_0\) and ends at \(x_n\). We can pick a random subinterval \([x_i,x_{i+1}]\) where \(0\le i \le n-1\). For example, your 1st interval will be \([x_0,x_1]\) and your <span class="math notranslate nohighlight">\(i=0\)</span>, and your last interval will be \([x_{n-1},x_n]\) and your \(i=n-1\).</p></li>
<li><p>For every subinterval, we approxiamte the slice to be a rectangle. To find the area of the rectangle we need to find the width and the height. The width of the rectangle is simply the width of the subinterval. The height of the rectangle can be estimated as the value of the function at the midpoint of the subinterval, so \(f \left ( \frac {x_{i+1}+x_i} {2} \right )\). To find the area we simply multiply the width of the rectangle by the height of the rectangle.</p>
<p>Width of the rectangle:</p>
<p>\[ x_{i+1} - x_i.\]</p>
<p>Height of the rectangle:</p>
<p>\[f \left ( \frac {x_{i+1}+x_i} {2} \right ).\]</p>
<p>Area of the rectangle:</p>
<p>\[(x_{i+1} - x_i) f \left ( \frac {x_{i+1}+x_i} {2} \right ).\]</p>
<p>Generalizing the above for all slices, where \(I_M^{(i)}\) is simply the area of the subinterval \([x_i,x_{i+1}]\). \(M\) subscript here denotes the use of the midpoint method.</p>
<p>\[ I_M^{(i)} := (x_{i+1}-x_i) \times f \left ( \frac {x_{i+1}+x_i} {2} \right ), \quad\text{for}
\quad 0\le i \le n-1.\]</p>
</li>
<li><p>To find the area under the curve, we need to sum up all of the areas from the subinterval, so we are going to use the summation symbol. We know that the subinterval index goes from the first subinterval where \(i=0\) to the last subinterval where \(i=n-1\), thus we arrive at</p></li>
</ol>
<p>\[I_M := \sum_{i=0}^{n-1} f \left ( \frac {x_{i+1}+x_i} {2} \right ) (x_{i+1}-x_i).\]</p>
<p>Note that we dropped \(i\) prefix from \(I\) because now it is the whole area under the curve, not just the area from one subinterval.</p>
<p>Let’s write some code to plot the idea as well as compute an estimate of the integral using the midpoint rule.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># this is a matplotlib function that allows us to easily plot rectangles</span>
<span class="c1"># which will be useful for visualising what the midpoint rule does</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The function we wish to integrate&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Get the value of pi from numpy and generate equally spaced values from 0 to pi.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Label axis.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x)=\sin(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

<span class="c1"># Overlay a grid.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">number_intervals</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">I_M</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">):</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                            <span class="n">f</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">I_M</span> <span class="o">+=</span> <span class="n">f</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;The sum of the areas of the rectangles is $I_M =$ </span><span class="si">{:.12f}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">I_M</span><span class="p">),</span>
              <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

    
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/8_Numerical_integration_4_0.png" src="../../_images/8_Numerical_integration_4_0.png" />
</div>
</div>
<p>A more complex example is shown below, where the red line shows the original function we wish to compute the integral of, and the blue rectangles <em>approximate</em> the area under that function for a number of sub-intervals:</p>
<p style="text-align:center;"><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/2/26/Integration_rectangle.svg/340px-Integration_rectangle.svg.png" width="600px"></p>
<div class="section" id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<div class="margin sidebar">
<p class="sidebar-title">Note</p>
<p>Note that the SciPy module features many different integration functions, and you can find thorough documentation for these functions (including methods not covered in this course) <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/integrate.html">here</a>. This library does not contain a function for the midpoint rule, but it is trivial to create our own.</p>
</div>
<p>Clearly the sum of the areas of all the rectangles provides an estimate of the true integral. In the case above we observe an error of around 1.5%.</p>
<p>As we are going to compare different rules below, let’s implement a midpoint rule function.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">midpoint_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Our implementation of the midpoint quadrature rule.</span>
<span class="sd">    </span>
<span class="sd">    a and b are the end points for our interval of interest.</span>
<span class="sd">    </span>
<span class="sd">    &#39;function&#39; is the function of x \in [a,b] which we can evaluate as needed.</span>
<span class="sd">    </span>
<span class="sd">    number_intervals is the number of subintervals/bins we split [a,b] into.</span>
<span class="sd">    </span>
<span class="sd">    Returns the integral of function(x) over [a,b].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">number_intervals</span>

    <span class="c1"># Some examples of some asserts which might be useful here - </span>
    <span class="c1"># you should get into the habit of using these sorts of checks as much as is possible/sensible.</span>
    <span class="k">assert</span> <span class="n">interval_size</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
    
    <span class="c1"># Initialise to zero the variable that will contain the cumulative sum of all the areas</span>
    <span class="n">I_M</span> <span class="o">=</span> <span class="mf">0.0</span>
    
    <span class="c1"># Find the first midpoint -- i.e. the centre point of the base of the first rectangle</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">interval_size</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="c1"># and loop until we get past b, creating and summing the area of each rectangle</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">):</span>
        <span class="c1"># Find the area of the current rectangle and add it to the running total</span>
        <span class="c1"># this involves an evaluation of the function at the subinterval midpoint</span>
        <span class="n">I_M</span> <span class="o">+=</span> <span class="n">interval_size</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span>
        <span class="c1"># Move the midpoint up to the next centre of the interval</span>
        <span class="n">mid</span> <span class="o">+=</span> <span class="n">interval_size</span>

    <span class="c1"># Return our running total result</span>
    <span class="k">return</span> <span class="n">I_M</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the function runs if it agrees with our first</span>
<span class="c1"># version used to generate the schematic plot of the method above:</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;midpoint_rule(0, np.pi, np.sin, number_intervals=5) = &#39;</span><span class="p">,</span>
      <span class="n">midpoint_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>midpoint_rule(0, np.pi, np.sin, number_intervals=5) =  2.033281476926104
</pre></div>
</div>
</div>
</div>
<p>Now let’s test the midpoint function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The exact area found by direct integration = 2&quot;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">):</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">midpoint_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Area </span><span class="si">%g</span><span class="s2"> rectangle(s) = </span><span class="si">%g</span><span class="s2"> (error=</span><span class="si">%g</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">area</span><span class="o">-</span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>The exact area found by direct integration = 2
Area 1 rectangle(s) = 3.14159 (error=1.14159)
Area 2 rectangle(s) = 2.22144 (error=0.221441)
Area 10 rectangle(s) = 2.00825 (error=0.00824841)
Area 100 rectangle(s) = 2.00008 (error=8.22491e-05)
Area 1000 rectangle(s) = 2 (error=8.22467e-07)
</pre></div>
</div>
</div>
</div>
<div class="dropdown tip admonition">
<p class="admonition-title">Exercise</p>
<p>Create a log-log plot of error egainst the number of subintervals:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a list of interval sizes to test </span>
<span class="n">interval_sizes_M</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">]</span>

<span class="c1"># Initialise an array to store the errors</span>
<span class="n">errors_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">interval_sizes_M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

<span class="c1"># Loop over the list of interval sizes, compute and store errors</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">interval_sizes_M</span><span class="p">):</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">midpoint_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">)</span>
    <span class="n">errors_M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">area</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Plot how the errors vary with interval size</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">interval_sizes_M</span><span class="p">,</span> <span class="n">errors_M</span><span class="p">,</span> <span class="s1">&#39;bo-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;log(no. of intervals)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;log(error)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Convergence plot for $\sin$ integration</span><span class="se">\n</span><span class="s1">with the midpoint rule&#39;</span><span class="p">,</span>
              <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">myst_nb</span> <span class="kn">import</span> <span class="n">glue</span>
<span class="n">glue</span><span class="p">(</span><span class="s2">&quot;midpoint_conv_fig&quot;</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

</pre></div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/8_Numerical_integration_11_0.png" src="../../_images/8_Numerical_integration_11_0.png" />
</div>
</div>
<p><strong>Observations:</strong></p>
<ul class="simple">
<li><p>With one rectangle, we are simply finding the area of a box of shape \(\pi \times 1\), where \(\pi\) is the width of the rectangle and \(1\) is the value of the function evaluated at the midpoint, \(\pi/2\). So of course the result is \(\pi\).</p></li>
<li><p>As we increase the number of subintervals, or rectangles, we increase the accuracy of our area. We can observe from the slope of the log-log plot of error against number of subintervals that the error is a quadratic function of the inverse of the number of subintervals (or equivalently is quadratically dependent on the spacing between the points - the interval size). This demonstrates that (for this particular example at least), the method demonstrates second-order accuracy - if we halve the interval size the error goes down by a factor of 4!</p></li>
<li><p>The simplicity of this method is its weakness, as rectangles (i.e. a flat top) are rarely a good approximation for the shape of a smooth function.</p></li>
<li><p>We want to use as few shapes as possible to approximate our function, because each additional rectangle is one extra time round the loop, which includes its own operations as well as an extra evaluation of the function, and hence increases the overall computational cost.</p></li>
</ul>
</div>
</div>
<div class="section" id="trapezoid-rule">
<span id="nm-trapezoid-rule"></span><h2>Trapezoid rule<a class="headerlink" href="#trapezoid-rule" title="Permalink to this headline">¶</a></h2>
<p>As previously stated, the slices we use do not have to be rectangles, they can also be trapezoids. Rectangle rule is very similar to the <strong>trapezoid rule</strong> except for one small difference.</p>
<p>For the trapezoid rule, the width of the subinterval will be multiplied by</p>
<p>\[\frac{f(x_i) + f(x_{i+1})}{2}.\]</p>
<p>For the trapezoid rule, the subscipt we will use the subscript \(T\). If we change the shape of the rectangle to a trapezoid (i.e. the top of the shape now being a linear line fit defined by the values of the function at the two end points of the subinterval, rather than the constant value used in the midpoint rule), we arrive at the trapezoid, or trapezoidal rule.</p>
<p>The trapezoid rule approximates the integral by the area of a trapezoid with base \((x_{i+1}-x_i)\) and the left- and right-hand-sides equal to the values of the function at the two end points.</p>
<p>In this case the area of the shape approximating the integral over one subinterval, is given by:</p>
<p>\[I_T^{(i)} := (x_{i+1}-x_i) \times
\left( \frac {f\left ( x_{i+1}\right ) + f \left (x_{i} \right )} {2} \right)
\quad\text{for}
\quad 0\le i \le n-1.\]</p>
<p>The trapezoidal estimate of \(I\) then simply involves summing up over all the subintervals:</p>
<p>\[I_T := \sum_{i=0}^{n-1}\left(\frac{f(x_{i+1}) + f(x_{i})}{2}\right )(x_{i+1}-x_i).\]</p>
<p>Let’s write some code to plot the idea and compute an estimate of the integral.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># This is a matplotlib function that allows us to plot polygons</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Polygon</span>

<span class="c1"># Get the value of pi from numpy and </span>
<span class="c1"># generate equally spaced values from 0 to pi.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># plot</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Label axis.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\sin(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Approximating function with trapezoids&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

<span class="c1"># Overlay a grid.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">number_intervals</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">I_T</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">):</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span> <span class="p">[</span>
                  <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])],</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">]]),</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">I_T</span> <span class="o">+=</span> <span class="p">((</span><span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;The sum of the areas of the trapezoids is $I_T =$ </span><span class="si">{:.12f}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">I_T</span><span class="p">),</span>
              <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

    
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/8_Numerical_integration_13_0.png" src="../../_images/8_Numerical_integration_13_0.png" />
</div>
</div>
<p>For our pictorial example used above, the approximation looks like it should be more accurate than the midpoint rule:</p>
<p style="text-align:center;"><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/0/03/Integration_trapezoid.svg/340px-Integration_trapezoid.svg.png" width="600px"></p>
<p>The tops of the shapes (now trapezoids) are approximating the variation of the function with a linear function, rather than a flat (constant) function. This looks like it should give more accurate results, but see below.</p>
<p>Note that numpy has a function for the trapezoid rule, <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.trapz.html"><code class="docutils literal notranslate"><span class="pre">numpy.trapz</span></code></a>, but we’ll make our own that works in a similar way to our midpoint rule function.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trapezoidal_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Our implementation of the trapezoidal quadrature rule.</span>
<span class="sd">    </span>
<span class="sd">    Note that as discussed in the lecture this version of the implementation </span>
<span class="sd">    performs redundant function evaluations - see the composite implementation </span>
<span class="sd">    in the homework for a more efficient version.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">number_intervals</span>

    <span class="k">assert</span> <span class="n">interval_size</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>

    <span class="n">I_T</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Loop to create each trapezoid</span>
    <span class="c1"># note this function takes a slightly different approach to Midpoint </span>
    <span class="c1"># (a for loop rather than a while loop) to achieve the same thing</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">):</span>
        <span class="c1"># Set the start of this interval </span>
        <span class="n">this_bin_start</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">interval_size</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
        <span class="c1"># Find the area of the current trapezoid and add it to the running total</span>
        <span class="n">I_T</span> <span class="o">+=</span> <span class="n">interval_size</span> <span class="o">*</span> \
                <span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">this_bin_start</span><span class="p">)</span><span class="o">+</span><span class="n">function</span><span class="p">(</span><span class="n">this_bin_start</span><span class="o">+</span><span class="n">interval_size</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span>

    <span class="c1"># Return our running total result</span>
    <span class="k">return</span> <span class="n">I_T</span>
</pre></div>
</div>
</div>
</div>
<p>We can test the function in a similar way:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The exact area found by direct integration = 2&quot;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">):</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">trapezoidal_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Area </span><span class="si">%g</span><span class="s2"> trapezoid(s) = </span><span class="si">%g</span><span class="s2"> (error=</span><span class="si">%g</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">area</span><span class="o">-</span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>The exact area found by direct integration = 2
Area 1 trapezoid(s) = 1.92367e-16 (error=2)
Area 2 trapezoid(s) = 1.5708 (error=0.429204)
Area 10 trapezoid(s) = 1.98352 (error=0.0164765)
Area 100 trapezoid(s) = 1.99984 (error=0.000164496)
Area 1000 trapezoid(s) = 2 (error=1.64493e-06)
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="error-analysis">
<h2>Error analysis<a class="headerlink" href="#error-analysis" title="Permalink to this headline">¶</a></h2>
<p>It is important to understand the errors of the numerical integration method we are using. If there are a limited number of slices, the area covered by the slices from trapezoid rule or the midpoint rule will not be slightly different from the actual area under the curve. Of course, if we increase the number of slices, the error becomes smaller; however, we also increase the computational power required.</p>
<p>A good numerical integration method should be able to have few slices, meaning using little computational power, but still be able to have a small error only. Thus, to know if the numerical integration method we used is a good or a bad method, we need to analyse the errors, or more exactly the change in the errors with numbers of slices, of our numerical integration method.</p>
<p>A good method will have a rapid decrease in the error when increasing the number of slices, while a bad method will have a slow decrease in the error when increasing the number of slices.</p>
<p>The accuracy of a quadrature, i.e. the mid point rule, the trapezoidal rule etc. is predicted by examining its behaviour in relationship with polynominals.</p>
<p>We say that the <em>degree of accuracy</em> or the <em>degree of precision</em> of a quadrature rule is equal to \(M\) if it is exact for all polynomials of degree up to and including \(M\), but not exact for some polynomial of degree \(M+1\).</p>
<div class="margin sidebar">
<p class="sidebar-title">Note</p>
<p>Test your own code on function \(x^2\) to demonstrate that midpoint and trapezoid rule won’t give the exact solution.</p>
</div>
<p>Clearly both the midpoint and trapezoid rules will give the exact result for both constant and linear functions, but they are not exact for quadratics. Therefore, they have a degree of precision of 1 (remember that through the error analysis, we found that it is 2nd order accurate, which is a different term to degree of precision!!).</p>
<div class="section" id="concave-down-functions">
<h3>Concave-down functions<a class="headerlink" href="#concave-down-functions" title="Permalink to this headline">¶</a></h3>
<p>The first half of a sine wave is concave-down and we notice from the plot that trapezoidal rule consistently <em>underestimate</em> the area under the curve as line segments are always under the curve.</p>
<p>In contrast, the mid-point rule will have parts of each rectangle above and below the curve, hence to a certain extent the <em>errors will cancel</em> each other out.</p>
<div class="cell_output docutils container">
<img alt="../../_images/8_Numerical_integration_19_0.png" src="../../_images/8_Numerical_integration_19_0.png" />
</div>
<p>This is why, <em>for this particular example</em>, the errors in the mid-point rule turn out to be approximately half those in the trapezoidal rule.</p>
<p>While this result turns out to be <em>generally</em> true for smooth functions, we can always come up with (counter) examples where the trapezoid rule will win.</p>
<p>Taylor series analysis can be used to formally construct upper bounds on the quadrature error for both methods.</p>
<p>We know that the error when integrating constant and linear functions is zero for our two rules, so let’s first consider an example of integrating a quadratic polynomial.</p>
<p>We know analytically that</p>
<p>\[\int_{0}^{1} x^{2},dx = \left.\frac{1}{3}x^3\right|_0^1=\frac {1}{3}.\]</p>
<p>Numerically, the midpoint rule on a single interval gives</p>
<p>\[ I_M = 1 \left(\frac {1}{2}\right)^{2} = \frac {1}{4},\]</p>
<p>while the trapezoidal rule gives</p>
<p>\[ I_T = 1 \frac {0+1^{2}}{2} = \frac {1}{2}.\]</p>
<p>The error for \(I_M\) is therefore \(1/3 - 1/4 = 1/12\), while the error for \(I_T\) is \(1/3 - 1/2 = -1/6\).</p>
<p>Therefore, the midpoint rule is twice as accurate as the trapezoid rule:</p>
<p>\[|E_M| = \frac{1}{2} |E_T|,\]</p>
<p>where \(|E|\) indicates the error (the absolute value of the difference from the exact solution).</p>
<p>This is the case for this simple example, and we can see from the actual error values printed above that it also appears to be approximately true for the sine case (which is not a simple polynomial) as well.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<img src="images_nm1/SIMPSONS.png">
</div>
</div>
</div>
<div class="section" id="simpson-s-rule">
<span id="nm-simpsons-rule"></span><h2>Simpson’s rule<a class="headerlink" href="#simpson-s-rule" title="Permalink to this headline">¶</a></h2>
<p>For our half sine wave, the rectangle method overestimates it by about 0.4%, while the trapezoid method underestimates it for 0.9%. We notice that in this situation, the rectangle method overestimates while the trapezoid method underestimates about twice the overestimate of the rectangle method. Could we combine this to obtain something more accurate?</p>
<p>Knowing the error estimates from the two rules explored so far opens up the potential for us to combine them in an appropriate manner to create a new quadrature rule, generally more accurate than either one separately.</p>
<p>Suppose \(I_S\) indicates an unknown, but more accurate, estimate of the integral over an interval. Then, as seen above, as \(I_T\) has an error that is approximately \(-2\) times the error in \(I_M\), the following relation must hold approximately:</p>
<p>\[I_S - I_T \approx -2 \left ( I_S - I_M\right ).\]</p>
<p>This follows from the fact that \(I - I_T \approx -2 \left ( I - I_M\right )\), provided that \(I_S\) is closer to \(I\) than either of the other two estimates. Replacing this approximately equals sign with actual equality defines \(I_S\) for us in terms of things we know.</p>
<p>We can rearrange this to give an expression for \(I_S\) that yields a more accurate estimate of the integral than either \(I_M\) or \(I_T\):</p>
<p>\[I_S := \frac{2}{3}I_M + \frac{1}{3}I_T.\]</p>
<p>We combined twice the overestimate from the rectangle method and once the underestimate from the trapezoid method, and then divided everything by 3 to obtain something more accurate! What we’re doing here is using the fact that we know something about (the <em>leading order</em> behaviour of the) two errors, and we can therefore combine them to cancel this error to a certain extent.</p>
<p>This estimate will generally be more accurate than either \(M\) or \(T\) alone. The error won’t be zero in general as we’re only cancelling out the leading order term in the error, but a consequence is that we will be left with higher-degree terms in the error expansion of the new quadrature rule which should be smaller (at least in the asymptotic limit), and converge faster.</p>
<p>The resulting quadrature method in this case is known as <a class="reference external" href="http://en.wikipedia.org/wiki/Simpson%27s_rule"><strong>Simpson’s rule</strong></a>. Let’s expand the Simpsons rule by substituting in what we know about the rectangle rule and the trapezoid rule:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
I_S &amp;:= \frac{2}{3}I_M + \frac{1}{3}I_T \\[5pt]
&amp;= \frac{2}{3}  (b-a)f\left ( \frac{a+b}{2}\right ) + \frac{1}{3}(b-a)\frac{(f(a) + f(b))}{2} \\[5pt]
&amp; = \frac{(b-a)}{6}\left( f \left ( a\right ) + 4f \left ( c\right ) + f\left ( b\right )\right),
\end{align*}
\end{split}\]</div>
<p>where \(a\) and \(b\) are the end points of an interval and \(c = \left ( a+b\right )/2\) is the midpoint.</p>
<p>Note that an alternate derivation of the same rule involves fitting a <em>quadratic function</em> (i.e. \(P_2(x)\) rather than the constant and linear approximations already considered) that interpolates the integral at the two end points of the interval, \(a\) and \(b\), as well as at the midpoint, \(c = \left ( a+b\right )/2\), and calculating the integral under that polynomial approximation.</p>
<p>Let’s plot what this method is doing and compute the integral for our sine case.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the value of pi from numpy and generate equally spaced values from 0 to pi.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># plot</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Label axis.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;sin(x)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Overlay a grid.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">number_intervals</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">I_S</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">):</span>
    <span class="c1"># Use a non-closed Polygon to visualise the straight sides of each interval </span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])]]),</span>
                          <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># Add the quadratic top - fit a quadratic using numpy</span>
    <span class="n">poly_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span>
                            <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">f</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Plot the quadratic using 20 plotting points within the interval </span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="mi">20</span><span class="p">),</span>
             <span class="n">f</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="mi">20</span><span class="p">)),</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># qdd in the area of the interval shape to our running total using Simpson&#39;s formula</span>
    <span class="n">I_S</span> <span class="o">+=</span> <span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mf">6.</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span>
                                     <span class="n">f</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;The Simpson&#39;s rule approximation is $I_s =$ </span><span class="si">{:.12f}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">I_S</span><span class="p">),</span>
              <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/8_Numerical_integration_21_0.png" src="../../_images/8_Numerical_integration_21_0.png" />
</div>
</div>
<p>It looks much closer to the actual function:</p>
<p style="text-align:center;"><img src="http://upload.wikimedia.org/wikipedia/commons/5/50/Integration_simpson.png" width="600px"></p>
<p>Let’s make a function to test it out.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simpsons_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Function to evaluate Simpson&#39;s rule. </span>
<span class="sd">    </span>
<span class="sd">    Note that this implementation takes the function as an argument, </span>
<span class="sd">    and evaluates this at the midpoint of subintervals in addition to the </span>
<span class="sd">    end point. Hence additional information is generated and used through </span>
<span class="sd">    additional function evaluations. </span>
<span class="sd">    </span>
<span class="sd">    This is different to the function/implementation available with SciPy  </span>
<span class="sd">    where discrete data only is passed to the function. </span>
<span class="sd">    </span>
<span class="sd">    Bear this in mind when comparing results - there will be a factor of two</span>
<span class="sd">    in the definition of &quot;n&quot; we need to be careful about!</span>
<span class="sd">    </span>
<span class="sd">    Also note that this version of the function performs redundant function </span>
<span class="sd">    evaluations - see the **composite** implementation below.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">interval_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">number_intervals</span>

    <span class="k">assert</span> <span class="n">interval_size</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>

    <span class="n">I_S</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Loop to valuate Simpson&#39;s formula over each interval </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">):</span>
        <span class="c1"># Find a, c, and b</span>
        <span class="n">this_bin_start</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">interval_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">this_bin_mid</span> <span class="o">=</span> <span class="n">this_bin_start</span> <span class="o">+</span> <span class="n">interval_size</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">this_bin_end</span> <span class="o">=</span> <span class="n">this_bin_start</span> <span class="o">+</span> <span class="n">interval_size</span>
        <span class="c1"># Calculate the rule and add to running total.</span>
        <span class="n">I_S</span> <span class="o">+=</span> <span class="p">(</span><span class="n">interval_size</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">this_bin_start</span><span class="p">)</span> <span class="o">+</span>
                                  <span class="mi">4</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">this_bin_mid</span><span class="p">)</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">this_bin_end</span><span class="p">))</span>

    <span class="c1"># Return our running total result</span>
    <span class="k">return</span> <span class="n">I_S</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s test the function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The area found by direct integration = 2&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">):</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">simpsons_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Area </span><span class="si">%g</span><span class="s2"> Simpson&#39;s interval(s) = </span><span class="si">%g</span><span class="s2"> (error=</span><span class="si">%g</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">area</span><span class="o">-</span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>The area found by direct integration = 2
Area 1 Simpson&#39;s interval(s) = 2.0944 (error=0.0943951)
Area 2 Simpson&#39;s interval(s) = 2.00456 (error=0.00455975)
Area 10 Simpson&#39;s interval(s) = 2.00001 (error=6.78444e-06)
Area 100 Simpson&#39;s interval(s) = 2 (error=6.76471e-10)
Area 1000 Simpson&#39;s interval(s) = 2 (error=6.79456e-14)
</pre></div>
</div>
</div>
</div>
<p>For this simple function you should find far smaller errors, and which drop much more rapidly with smaller \(h\) (or more sub-intervals).</p>
<p><strong>Observations:</strong></p>
<ul>
<li><p>The errors are lower than for the midpoint and trapezoidal rules, and the method converges more rapidly - i.e. the relative improvement only gets better for more subintervals.</p></li>
<li><p>This expression now integrates up to cubics exactly (by construction), so it is of order 4 (if we halve the interval size, the error goes by a factor of \(2^4=16\)).</p>
<p>The convergence can be confirmed in the plot below:</p>
<div class="cell_output docutils container">
<img alt="../../_images/8_Numerical_integration_27_0.png" src="../../_images/8_Numerical_integration_27_0.png" />
</div>
</li>
<li><p>The degree of accuracy or precision of this method is 3.</p></li>
<li><p>Simpson’s rule integrates to cubics exactly, so since it’s integrating exactly, cubics cannot contribute to the error. Only the quartic (4th) order terms contribute to the error, so it’s 4th order accurate.</p></li>
<li><p>We’re getting down to errors close to the machine precision now when we use 1000 subintervals. Remember: your average consumer grade hardware can only handle that many decimal points, and you will need some rather expensive hardware to have even higher levels of precisions. Continuing with 1000 subintervals is actually not helpful as the error that you will get stops decreasing as it is so small that your computer stops being able to discriminate it from 0. Remember we may well either have a relatively small number of data points, or want to minimise the number of function evaluations well below this relatively high number. This will mean that for problems with lots of variation, and/or in higher dimensions, that we still work to do in improving our quadrature methods.</p></li>
<li><p>As was the case with our first trapezoidal implementation, we are performing unnecessary function evaluations here; we can fix this issue through the implementation of a so-called <em>composite</em> version of the rule, which still gives the same result as your Simpson’s rule, but makes it but easier for the computer. The composite Simpson’s rule still does many evaluations, but fewer evaluations than your standard Simpson’s rule.</p></li>
</ul>
</div>
<div class="section" id="composite-simpson-s-rule">
<span id="nm-composite-simpsons-rule"></span><h2>Composite Simpson’s rule<a class="headerlink" href="#composite-simpson-s-rule" title="Permalink to this headline">¶</a></h2>
<p>If we assume that our interval \([a,b]\) has been split up into \(n\) intervals (or \(n+1\) data points) we can save some function evaluations by writing Simpson’s rule in the following form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
I_{S} 
&amp; = \frac{\Delta x}{3}\left[ f \left ( x_0\right ) + 4f \left ( x_1\right ) + 2f\left ( x_2\right ) + 4f \left ( x_3\right ) + \cdots + 2 f \left ( x_{n-2}\right )  + 4 f \left ( x_{n-1}\right ) +  f \left ( x_{n}\right ) \right]\\[5pt]
&amp; = \frac{\Delta x}{3}\left[ f \left ( x_0\right ) + 2\sum_{i=1}^{n/2 - 1} f\left(x_{2i}\right) + 4\sum_{i=1}^{n/2} f\left(x_{2i-1}\right)  +  f \left ( x_{n}\right ) \right].
\end{align*}
\end{split}\]</div>
<p>This is known as the <a class="reference external" href="http://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson.27s_rule">composite Simpson’s rule</a>,
or more precisely the <em>composite Simpson’s 1/3 rule</em>.</p>
<p>You can find a version of Simpson’s rule implemented by SciPy - <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.simps.html"><code class="docutils literal notranslate"><span class="pre">scipy.interpolate.simps</span></code></a>.</p>
<p>Note that this way of formulating Simpson’s rule (where we do not allow additional function evaluations at the midpoints of intervals - we assume we are only in a position to use the given data points) requires that \(n\) be even.</p>
<p>This way of writing the composite form in the case of \(n=2\) is equivalent to the formula over \([a,b]\) that introduced the additional midpoint location \(c\).</p>
<p>Let’s implement this rule:</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simpsons_composite_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to evaluate the composite Simpson&#39;s rule only using</span>
<span class="sd">    function evaluations at (number_intervals + 1) points.</span>
<span class="sd">    </span>
<span class="sd">    This implementation requires that the number of subintervals (number_intervals) be even</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">number_intervals</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;number_intervals is not even&quot;</span>

    <span class="n">interval_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">number_intervals</span>
    <span class="c1"># Start with the two end member values</span>
    <span class="n">I_cS2</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="c1"># Add in those terms with a coefficient of 4</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">I_cS2</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">interval_size</span><span class="p">)</span>

    <span class="c1"># And those terms with a coefficient of 2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">I_cS2</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">interval_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">I_cS2</span> <span class="o">*</span> <span class="p">(</span><span class="n">interval_size</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s test the rule:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The area found by direct integration = 2&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">):</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Area </span><span class="si">%g</span><span class="s2"> rectangle(s) = </span><span class="si">%g</span><span class="s2"> (error=</span><span class="si">%g</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">area</span><span class="o">-</span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>The area found by direct integration = 2
Area 2 rectangle(s) = 2.0944 (error=0.0943951)
Area 10 rectangle(s) = 2.00011 (error=0.000109517)
Area 100 rectangle(s) = 2 (error=1.08245e-08)
Area 1000 rectangle(s) = 2 (error=1.07869e-12)
</pre></div>
</div>
</div>
</div>
<p>This is a slight improvement for a simple function like \(\sin\), but will be much more of an improvement for functions which oscillate more, in a relative sense compared to the size of our bins.</p>
</div>
<div class="section" id="weddle-s-rule">
<span id="nm-weddles-rule"></span><h2>Weddle’s rule<a class="headerlink" href="#weddle-s-rule" title="Permalink to this headline">¶</a></h2>
<p>We noted above that Simpson’s rule is fourth-order accurate. Suppose we take an approximation to \(I\) using \(n\) subintervals with Simpson’s rule and call the result \(I_S\), and then apply Simpson’s rule with double the number of intervals (\(2n\)) and call the result \(I_{S_2}\).</p>
<p>Then we have two estimates for the integral where we expect \(I_{S_2}\) to be approximately \(2^4=16\) times more accurate than \(S\). In particular, we expect the lowest (i.e. the leading) order error term in \(I_{S_2}\) to be precisely one sixteenth that of \(I_S\).</p>
<p>Similar to how we derived Simpson’s rule by combining what we knew of the error for the midpoint and trapezoidal rules, with this knowledge we can combine the two estimates from Simpson’s rule to derive an even more accurate estimate of \(I\).</p>
<p>Let’s call this more accurate rule \(I_W\), which we can find by solving:</p>
<p>\[I_W - I_S = 16 \left ( I_W - I_{S_2} \right ),\]
for \(I_W\).</p>
<p>With a bit of manipulation,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
&amp;amp; \;\;\; I_W - I_S = 16 \left ( I_W - I_{S_2} \right ) \\[5pt]
\implies &amp;amp; \;\;\; I_W - I_S = 16 I_W - 16 I_{S_2} \\[5pt]
\implies &amp;amp; \;\;\; 15 I_W  = 16 I_{S_2} - I_S \\[5pt]
\implies &amp;amp; \;\;\; 15 I_W  = 15 I_{S_2} + (I_{S_2} - I_S) ,
\end{align*}\end{split}\]</div>
<p>we get this expression</p>
<p>\[ I_W = I_{S_2} + \frac {\left (I_{S_2} - I_S \right )}{15}.\]</p>
<p>This is known as <strong>Weddle’s rule</strong>, or the extrapolated Simpson’s rule because it uses two different values for the interval size and extrapolates from these two to obtain an even more accurate result.</p>
<p>Making a function for this rule is easy as we can just call our Simpson’s rule functions with two values for the number of intervals.</p>
<div class="section" id="id1">
<h3>Implementation<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>We can implement this by calling already created functions for composite Simpson’s rule:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">weddles_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Function to evaluate Weddle&#39;s quadrature rule using</span>
<span class="sd">    appropriate calls to the composite_simpson function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">)</span>
    <span class="n">S2</span> <span class="o">=</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">S2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S2</span> <span class="o">-</span> <span class="n">S</span><span class="p">)</span><span class="o">/</span><span class="mf">15.</span>
</pre></div>
</div>
</div>
</div>
<p>We can test it in a similar way:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">):</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">weddles_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Area with </span><span class="si">%g</span><span class="s2"> Weddle&#39;s interval(s) = </span><span class="si">%g</span><span class="s2"> (error=</span><span class="si">%g</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">area</span><span class="o">-</span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Area with 2 Weddle&#39;s interval(s) = 1.99857 (error=0.00142927)
Area with 10 Weddle&#39;s interval(s) = 2 (error=6.44164e-08)
Area with 100 Weddle&#39;s interval(s) = 2 (error=6.23945e-14)
Area with 1000 Weddle&#39;s interval(s) = 2 (error=8.88178e-16)
</pre></div>
</div>
</div>
</div>
<p>Our final result is much more accurate for fewer required bins:</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="../../_images/8_Numerical_integration_37_0.png" src="../../_images/8_Numerical_integration_37_0.png" />
</div>
</div>
</div>
</div>
<div class="section" id="other-rules">
<h2>Other rules<a class="headerlink" href="#other-rules" title="Permalink to this headline">¶</a></h2>
<p>Note that the above technique of using the same rule, but with different values for the interval size, \(h\), to derive a more accurate estimate of the integral is an example of what is more generally called <em>Richardson extrapolation</em>. Performing this approach using the trapezoid rule as the starting point leads to what is termed <em>Romberg integration</em>.</p>
<p>Taking the idea behind Simpson’s rule which fits a quadratic Lagrange interpolating polynomial to <em>equally spaced</em> points in the interval, end extending to any order Lagrange polynomial leads to the <a class="reference external" href="https://en.wikipedia.org/wiki/Newton%E2%80%93Cotes_formulas"><em>Newton-Cotes</em> family of quadrature rules</a>.</p>
<p>Note finally, that even wider families exist where the function being integrated is evaluated at non-equally-spaced points. And of course for practical application these ideas need to be extended to more than one dimension.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "primer-computational-mathematics/book",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./c_mathematics/numerical_methods"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="7_Forward_time_centred_space.html" title="previous page">Forward Time Centred Space scheme</a>
    <a class='right-next' id="next-link" href="9_Roots_of_equations.html" title="next page">Roots of equations</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Imperial College London<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../../_static/js/index.js"></script>
    
  </body>
</html>